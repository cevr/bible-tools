diff --git a/dist/cjs/internal/commandDescriptor.js b/dist/cjs/internal/commandDescriptor.js
index eea280e3c0c5e3dea211ba64ee8a5a50b651aaa9..49fff581ad7d77c6639b73309153759dc4c922b7 100644
--- a/dist/cjs/internal/commandDescriptor.js
+++ b/dist/cjs/internal/commandDescriptor.js
@@ -350,7 +350,14 @@ const parseInternal = (self, args, config) => {
       {
         const names = getNamesInternal(self);
         const subcommands = getSubcommandsInternal(self);
-        const [parentArgs, childArgs] = Arr.span(args, arg => !Arr.some(subcommands, ([name]) => name === arg));
+        const subcommandNames = Arr.map(subcommands, ([name]) => name);
+        const parentOptionNames = getParentOptionNames(self.parent);
+        const {
+          parentArgs: extractedParentArgs,
+          remainingArgs
+        } = extractParentOptionsFromArgs(args, parentOptionNames, subcommandNames);
+        const [preSubcommandArgs, childArgs] = Arr.span(remainingArgs, arg => !Arr.some(subcommands, ([name]) => name === arg));
+        const parentArgs = Arr.appendAll(preSubcommandArgs, extractedParentArgs);
         const parseChildrenWith = argsForChildren => Effect.suspend(() => {
           const iterator = self.children[Symbol.iterator]();
           const loop = next => {
@@ -450,6 +457,81 @@ const splitForcedArgs = args => {
   const [remainingArgs, forcedArgs] = Arr.span(args, str => str !== "--");
   return [remainingArgs, Arr.drop(forcedArgs, 1)];
 };
+const getParentOptionNames = self => {
+  const names = new Set();
+  const collectFromCommand = cmd => {
+    switch (cmd._tag) {
+      case "Standard":
+        {
+          const optionNames = InternalOptions.getNames(cmd.options);
+          for (const name of optionNames) {
+            names.add(name);
+          }
+          break;
+        }
+      case "Map":
+        {
+          collectFromCommand(cmd.command);
+          break;
+        }
+      case "Subcommands":
+        {
+          collectFromCommand(cmd.parent);
+          break;
+        }
+      case "GetUserInput":
+        {
+          break;
+        }
+    }
+  };
+  collectFromCommand(self);
+  return names;
+};
+const extractParentOptionsFromArgs = (args, parentOptionNames, subcommandNames) => {
+  const parentArgs = [];
+  const remainingArgs = [];
+  let i = 0;
+  let foundSubcommand = false;
+  while (i < args.length) {
+    const arg = args[i];
+    if (!foundSubcommand && subcommandNames.includes(arg)) {
+      foundSubcommand = true;
+      remainingArgs.push(arg);
+      i++;
+      continue;
+    }
+    if (!foundSubcommand) {
+      remainingArgs.push(arg);
+      i++;
+      continue;
+    }
+    if (arg.startsWith("-")) {
+      const equalsIndex = arg.indexOf("=");
+      const optionName = equalsIndex !== -1 ? arg.substring(0, equalsIndex) : arg;
+      if (parentOptionNames.has(optionName)) {
+        if (equalsIndex !== -1) {
+          parentArgs.push(arg);
+          i++;
+        } else {
+          parentArgs.push(arg);
+          i++;
+          if (i < args.length && !args[i].startsWith("-") && !subcommandNames.includes(args[i])) {
+            parentArgs.push(args[i]);
+            i++;
+          }
+        }
+        continue;
+      }
+    }
+    remainingArgs.push(arg);
+    i++;
+  }
+  return {
+    parentArgs,
+    remainingArgs
+  };
+};
 const withDescriptionInternal = (self, description) => {
   switch (self._tag) {
     case "Standard":
diff --git a/dist/esm/internal/commandDescriptor.js b/dist/esm/internal/commandDescriptor.js
index e22f89bd5e628b352d73cb77c7d2d9cecb375280..8c5a1ebdd75af658ab75c0d63e6bdb28ef4b698d 100644
--- a/dist/esm/internal/commandDescriptor.js
+++ b/dist/esm/internal/commandDescriptor.js
@@ -329,7 +329,14 @@ const parseInternal = (self, args, config) => {
       {
         const names = getNamesInternal(self);
         const subcommands = getSubcommandsInternal(self);
-        const [parentArgs, childArgs] = Arr.span(args, arg => !Arr.some(subcommands, ([name]) => name === arg));
+        const subcommandNames = Arr.map(subcommands, ([name]) => name);
+        const parentOptionNames = getParentOptionNames(self.parent);
+        const {
+          parentArgs: extractedParentArgs,
+          remainingArgs
+        } = extractParentOptionsFromArgs(args, parentOptionNames, subcommandNames);
+        const [preSubcommandArgs, childArgs] = Arr.span(remainingArgs, arg => !Arr.some(subcommands, ([name]) => name === arg));
+        const parentArgs = Arr.appendAll(preSubcommandArgs, extractedParentArgs);
         const parseChildrenWith = argsForChildren => Effect.suspend(() => {
           const iterator = self.children[Symbol.iterator]();
           const loop = next => {
@@ -429,6 +436,81 @@ const splitForcedArgs = args => {
   const [remainingArgs, forcedArgs] = Arr.span(args, str => str !== "--");
   return [remainingArgs, Arr.drop(forcedArgs, 1)];
 };
+const getParentOptionNames = self => {
+  const names = new Set();
+  const collectFromCommand = cmd => {
+    switch (cmd._tag) {
+      case "Standard":
+        {
+          const optionNames = InternalOptions.getNames(cmd.options);
+          for (const name of optionNames) {
+            names.add(name);
+          }
+          break;
+        }
+      case "Map":
+        {
+          collectFromCommand(cmd.command);
+          break;
+        }
+      case "Subcommands":
+        {
+          collectFromCommand(cmd.parent);
+          break;
+        }
+      case "GetUserInput":
+        {
+          break;
+        }
+    }
+  };
+  collectFromCommand(self);
+  return names;
+};
+const extractParentOptionsFromArgs = (args, parentOptionNames, subcommandNames) => {
+  const parentArgs = [];
+  const remainingArgs = [];
+  let i = 0;
+  let foundSubcommand = false;
+  while (i < args.length) {
+    const arg = args[i];
+    if (!foundSubcommand && subcommandNames.includes(arg)) {
+      foundSubcommand = true;
+      remainingArgs.push(arg);
+      i++;
+      continue;
+    }
+    if (!foundSubcommand) {
+      remainingArgs.push(arg);
+      i++;
+      continue;
+    }
+    if (arg.startsWith("-")) {
+      const equalsIndex = arg.indexOf("=");
+      const optionName = equalsIndex !== -1 ? arg.substring(0, equalsIndex) : arg;
+      if (parentOptionNames.has(optionName)) {
+        if (equalsIndex !== -1) {
+          parentArgs.push(arg);
+          i++;
+        } else {
+          parentArgs.push(arg);
+          i++;
+          if (i < args.length && !args[i].startsWith("-") && !subcommandNames.includes(args[i])) {
+            parentArgs.push(args[i]);
+            i++;
+          }
+        }
+        continue;
+      }
+    }
+    remainingArgs.push(arg);
+    i++;
+  }
+  return {
+    parentArgs,
+    remainingArgs
+  };
+};
 const withDescriptionInternal = (self, description) => {
   switch (self._tag) {
     case "Standard":
diff --git a/src/internal/commandDescriptor.ts b/src/internal/commandDescriptor.ts
index 5b8437800aaf94aafb6a67eeb3bb9caa74bc080d..31ecce216ed99ec9ad6fe34050d4c81008b2d617 100644
--- a/src/internal/commandDescriptor.ts
+++ b/src/internal/commandDescriptor.ts
@@ -669,10 +669,27 @@ const parseInternal = (
     case "Subcommands": {
       const names = getNamesInternal(self)
       const subcommands = getSubcommandsInternal(self)
-      const [parentArgs, childArgs] = Arr.span(
+      const subcommandNames = Arr.map(subcommands, ([name]) => name)
+
+      // Get parent option names so we can extract them from anywhere in args
+      const parentOptionNames = getParentOptionNames(self.parent)
+
+      // Extract parent options that appear after the subcommand
+      const { parentArgs: extractedParentArgs, remainingArgs } = extractParentOptionsFromArgs(
         args,
+        parentOptionNames,
+        subcommandNames
+      )
+
+      // Split remaining args at subcommand boundary (original logic)
+      const [preSubcommandArgs, childArgs] = Arr.span(
+        remainingArgs,
         (arg) => !Arr.some(subcommands, ([name]) => name === arg)
       )
+
+      // Combine args before subcommand with extracted parent options
+      const parentArgs = Arr.appendAll(preSubcommandArgs, extractedParentArgs)
+
       const parseChildrenWith = (argsForChildren: ReadonlyArray<string>) =>
         Effect.suspend(() => {
           const iterator = self.children[Symbol.iterator]()
@@ -828,6 +845,106 @@ const splitForcedArgs = (
   return [remainingArgs, Arr.drop(forcedArgs, 1)]
 }
 
+/**
+ * Get all option names (including aliases) from a command's options.
+ * Traverses through Map and Subcommands wrappers to find Standard commands.
+ */
+const getParentOptionNames = (self: Instruction): Set<string> => {
+  const names = new Set<string>()
+  const collectFromCommand = (cmd: Instruction): void => {
+    switch (cmd._tag) {
+      case "Standard": {
+        const optionNames = InternalOptions.getNames(cmd.options as InternalOptions.Instruction)
+        for (const name of optionNames) {
+          names.add(name)
+        }
+        break
+      }
+      case "Map": {
+        collectFromCommand(cmd.command)
+        break
+      }
+      case "Subcommands": {
+        collectFromCommand(cmd.parent)
+        break
+      }
+      case "GetUserInput": {
+        break
+      }
+    }
+  }
+  collectFromCommand(self)
+  return names
+}
+
+/**
+ * Extract parent options from anywhere in the args array.
+ * Returns { parentArgs: extracted parent options, remainingArgs: everything else }
+ */
+const extractParentOptionsFromArgs = (
+  args: ReadonlyArray<string>,
+  parentOptionNames: Set<string>,
+  subcommandNames: ReadonlyArray<string>
+): { parentArgs: Array<string>; remainingArgs: Array<string> } => {
+  const parentArgs: Array<string> = []
+  const remainingArgs: Array<string> = []
+
+  let i = 0
+  let foundSubcommand = false
+
+  while (i < args.length) {
+    const arg = args[i]
+
+    // Once we hit a subcommand, check subsequent args for parent options
+    if (!foundSubcommand && subcommandNames.includes(arg)) {
+      foundSubcommand = true
+      remainingArgs.push(arg)
+      i++
+      continue
+    }
+
+    // Only extract parent options AFTER the subcommand has been found
+    // Before the subcommand, args go to remaining (original behavior)
+    if (!foundSubcommand) {
+      remainingArgs.push(arg)
+      i++
+      continue
+    }
+
+    // Check if this is a parent option (starts with - and matches parent option names)
+    if (arg.startsWith("-")) {
+      // Handle --option=value format
+      const equalsIndex = arg.indexOf("=")
+      const optionName = equalsIndex !== -1 ? arg.substring(0, equalsIndex) : arg
+
+      if (parentOptionNames.has(optionName)) {
+        // This is a parent option - extract it
+        if (equalsIndex !== -1) {
+          // --option=value format - single arg contains both
+          parentArgs.push(arg)
+          i++
+        } else {
+          // Check if next arg is the value (not another option, not a subcommand)
+          parentArgs.push(arg)
+          i++
+          if (i < args.length && !args[i].startsWith("-") && !subcommandNames.includes(args[i])) {
+            // Next arg is the value for this option
+            parentArgs.push(args[i])
+            i++
+          }
+        }
+        continue
+      }
+    }
+
+    // Not a parent option - keep in remaining
+    remainingArgs.push(arg)
+    i++
+  }
+
+  return { parentArgs, remainingArgs }
+}
+
 const withDescriptionInternal = (
   self: Instruction,
   description: string | HelpDoc.HelpDoc
